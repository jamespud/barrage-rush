# barrage-rush

# 分布式高性能弹幕系统设计文档

## 一、系统架构概览

### 全球架构部署

- **多区域部署**：全球划分为多个服务区域（如华东、华北、北美、欧洲等）
- **区域内部署**：每个区域部署 API 服务集群、WebSocket 服务集群、缓存集群、消息队列集群
- **全局组件**：跨区域消息总线、全球分布式缓存、全局配置中心

### 核心组件

1. **接入层**：负载均衡、CDN 加速、地理路由
2. **API 服务**：处理弹幕发送请求、用户认证、消息验证
3. **WebSocket 服务**：维护用户长连接、消息推送
4. **消息队列**：区域内消息分发、跨区域消息同步
5. **分布式缓存**：用户会话管理、热点数据缓存、实时消息存储
6. **数据库**：消息持久化、用户数据、房间配置
7. **配置中心**：动态配置管理、全局规则下发
8. **监控系统**：业务监控、性能监控、告警系统

### 混合架构设计

![img](.assert\lkme1aylpv.jpeg)

## 二、用户连接流程

1. **用户初始化连接**

    - 客户端请求 DNS 解析直播域名
    - DNS 根据用户 IP 返回最近的接入点地址
    - 客户端请求接入层建立连接

2. **地理位置路由**

    - 接入层获取用户 IP 地址
    - 调用地理位置服务确定最近的服务区域
    - 将请求路由到对应区域的入口网关

3. **WebSocket 连接建立**

    - 客户端发起 WebSocket 连接请求

   ```
   ws://danmaku-{region}.example.com/ws/{roomId}?token={userToken}
   ```

    - 服务端进行握手拦截和权限验证
    - 连接成功后记录用户会话信息

4. **会话初始化**
    - 服务端为用户创建会话对象
    - 将用户加入房间成员列表
    - 将会话信息同步到分布式缓存
    - 从 Redis 获取并发送历史弹幕数据（最近 N 条）
    - 向客户端发送连接成功确认

## 三、弹幕处理流程（混合架构）

### POST 请求发送弹幕

1. **客户端弹幕发送**

    - 用户输入弹幕内容并设置样式
    - 客户端组装 HTTP POST 请求

   ```
   POST /api/v1/danmaku
   {
     "roomId": 123456,
     "content": "弹幕内容",
     "type": "NORMAL",
     "style": {"color":"#FFFFFF", "fontSize":14}
   }
   ```

    - 发送请求到 API 服务
    - 本地渲染预显示（降低感知延迟）

2. **API 服务处理**

    - 接收到弹幕 POST 请求
    - Spring Security 进行身份认证和权限校验
    - 获取用户 ID 和权限信息
    - 记录接收时间戳
    - 返回 HTTP 响应给客户端

3. **消息验证**

    - 检查用户权限（是否被禁言）
    - 验证消息格式合法性
    - 检查内容长度（不超过最大限制）
    - 检查敏感词（基础过滤）
    - 验证发送频率（防刷屏）

4. **业务逻辑处理**

    - 检查房间状态（是否允许发言）
    - 应用房间特定规则（VIP 优先级、颜色限制等）
    - 应用内容智能过滤（复杂过滤规则）
    - 计算用户积分/经验值（如适用）

5. **消息入队**
    - 生成全局唯一消息 ID（基于雪花算法）
    - 添加元数据（服务器节点信息、区域标识）
    - 设置消息来源标识（防止循环处理）
    - 发布到消息队列（Kafka/RabbitMQ）

### 消息队列处理与持久化

1. **消息消费**

    - 消息队列消费者接收弹幕消息
    - 提取消息内容和元数据
    - 根据业务需求进行分流处理

2. **数据持久化**

    - 将弹幕消息写入 MySQL 数据库
    - 按房间 ID 和时间戳分表或分区
    - 设置适当的过期策略
    - 可选择异步批量写入提高性能

3. **缓存更新**

    - 将消息写入 Redis ZSet 结构

   ```
   ZADD room:danmaku:123456 1684279936482 "{...消息内容...}"
   ```

    - 使用时间戳作为分数，实现按时间排序
    - 限制 ZSet 大小，自动淘汰旧消息
    - 设置合理的过期时间

4. **本地缓存构建**
    - 服务实例定期从 Redis 同步热门房间弹幕数据
    - 构建本地内存缓存（如 Caffeine 缓存）
    - 设置基于热度的动态缓存策略
    - 降低 Redis 读取压力

### WebSocket 消息推送

1. **推送触发机制**

    - 监听 Redis 的 Pub/Sub 通道获取新消息
    - 或通过 Kafka 消费实时消息流
    - 接收新弹幕消息通知

2. **用户会话查找**

    - 根据房间 ID 查询所有相关 WebSocket 会话
    - 从会话管理器获取连接信息
    - 检查会话状态（是否仍有效）

3. **消息推送**

    - 将消息转换为 WebSocket 格式

   ```json
   {
     "type": "DANMAKU",
     "data": {
       "messageId": "16842799364821001",
       "roomId": 123456,
       "userId": 789012,
       "username": "用户名",
       "content": "弹幕内容",
       "timestamp": 1684279936482,
       "style": { "color": "#FFFFFF", "fontSize": 14 }
     }
   }
   ```

    - 推送消息到相关会话
    - 记录推送结果统计

4. **用户级别过滤**
    - 应用用户个人设置的过滤规则
    - 处理用户屏蔽关系（如屏蔽了某发送者）
    - 根据用户偏好调整弹幕显示优先级

## 四、区域内消息分发流程

1. **房间分区策略**

    - 按房间 ID 对消息进行分区路由
    - 确保同一房间的消息由固定分区处理
    - 保证单个房间内消息顺序

2. **区域内高效分发**

    - 将消息复制到区域内所有 WebSocket 服务实例
    - 或采用会话分片策略，每个实例只处理部分会话
    - 使用异步并行推送技术

3. **推送性能优化**

    - 批量推送聚合（减少 IO 操作）
    - 消息压缩传输（减少带宽占用）
    - 利用零拷贝技术提高传输效率
    - 线程池管理和优化

4. **推送结果跟踪**
    - 统计成功推送数量
    - 记录推送延迟情况
    - 处理推送失败的会话
    - 更新房间活跃度指标

## 五、跨区域消息同步流程

1. **全球消息总线设计**

    - Kafka 集群跨区域镜像复制
    - 按地区配置专门的复制主题
    - 设置适当的复制因子保证可靠性
    - 优化网络路由减少跨区域延迟

2. **消息全球同步格式**

   ```json
   {
     "messageId": "16842799364821001",
     "sourceRegion": "cn-east-1",
     "roomId": "12345",
     "timestamp": 1684279936482,
     "traceId": "trace-16842799364821001",
     "payload": {
       /* 原始弹幕消息 */
     },
     "metadata": {
       "priority": 0,
       "version": 1,
       "sourceNode": "api-server-12"
     }
   }
   ```

3. **跨区域消息处理**

    - 目标区域接收跨区域消息
    - 消息去重检查（防止循环处理）
    - 本地化处理（添加区域标识）
    - 应用区域特定规则和过滤

4. **延迟补偿策略**

    - 对高延迟消息进行特殊标记
    - 基于时间戳排序确保顺序
    - 超高延迟消息可能主动丢弃
    - 提供延迟指标监控

5. **全球一致性保障**
    - 全局唯一消息 ID 确保去重
    - 基于版本号的冲突解决
    - 跨区域状态同步机制
    - 数据一致性校验工具

## 六、高可用保障机制

1. **心跳与会话维护**

- 客户端定期发送心跳包（30 秒间隔）
    - 服务端更新会话最后活跃时间
    - 清理长时间无响应的会话（90 秒超时）
    - 自动释放僵尸连接资源

2. **弹幕失败重试机制**

    - 检测消息发送失败情况
    - 按照指数退避策略进行重试
    - 最多重试 3 次后放弃
    - 记录持久化失败的消息

3. **熔断与限流保护**

    - 实时监控系统负载情况
    - 对超高并发房间实施特殊处理
    - 在系统负载过高时启动保护策略
    - 对非关键操作进行熔断降级

4. **灾备与故障转移**
    - 监控区域健康状态
    - 在区域故障时重定向用户连接
    - 启动数据恢复和同步机制
    - 确保核心业务连续性

## 七、监控与运维流程

1. **实时监控指标**

    - API 服务调用量和响应时间
    - WebSocket 连接数和消息吞吐量
    - Redis 操作延迟和命中率
    - 跨区域消息同步延迟
    - 异常事件计数和告警

2. **告警与自动响应**

    - 设置关键指标阈值告警
    - 异常事件实时通知
    - 自动扩缩容响应负载变化
    - 自动故障处理流程

3. **业务指标分析**

    - 热门房间实时排行
    - 用户活跃度分析
    - 高峰期负载预测
    - 区域流量分布情况

4. **问题诊断与溯源**
    - 全链路追踪支持
    - 用户投诉快速定位
    - 性能瓶颈识别
    - 异常事件根因分析

## 八、特殊场景处理

1. **超高并发直播间**

    - 识别热点房间（实时监控）
    - 预分配更多资源
    - 启用特殊分发策略（采样推送）
    - 弹幕聚合处理（减少推送频率）

2. **跨区域网络波动**

    - 检测区域间连接质量
    - 启用备用路由策略
    - 暂存消息等待连接恢复
    - 网络恢复后执行批量同步

3. **用户网络切换**

    - 检测客户端网络变化
    - 支持快速重连机制
    - 恢复中断前会话状态
    - 补发中断期间的消息

4. **大型活动预案**
    - 活动前资源预热
    - 流量预测与容量规划
    - 启用预定义的流控策略
    - 建立专项监控面板

## 九、性能优化策略

1. **多级缓存架构**

    - WebSocket 服务本地缓存（JVM 堆内）
    - 区域级 Redis 共享缓存
    - 全球分布式缓存系统
    - 智能缓存预热和淘汰

2. **数据读写分离**

    - POST 请求写入（安全性和可靠性）
    - WebSocket 推送读取（实时性和高效性）
    - 异步处理分离读写压力
    - 针对读多写少特性优化

3. **弹幕发送优化**

    - POST 请求处理的高效验证
    - 批量消息入队减少 IO 操作
    - 消息异步处理提高吞吐量
    - Spring Security 优化鉴权性能

4. **弹幕接收优化**

    - WebSocket 高效二进制传输
    - 消息压缩减少网络带宽
    - 客户端渲染优化减轻感知延迟
    - 定向推送避免无效传输

5. **地理加速策略**
    - 根据用户地理位置智能路由
    - 跨区域专线传输
    - 边缘节点部署
    - CDN 辅助加速

通过此混合架构设计，分布式弹幕系统既保证了弹幕发送的安全性和可靠性（POST 请求），又实现了接收端的实时性和高效性（WebSocket
推送）。系统能够在全球范围内高效、低延迟地同步和展示弹幕消息，为用户提供流畅一致的体验。

---

参考资料:

[1] [如何设计一个高性能百万的直播弹幕系统，听我娓娓道来 ...](https://blog.csdn.net/2401_89221445/article/details/144248964)

[2] [假如让你从 0 到 1 实现一个直播弹幕系统](https://cloud.tencent.com/developer/article/1645888)

[3] [实现高效直播弹幕功能：Spring Boot 的最佳技术选择](https://blog.csdn.net/guzhoumingyue/article/details/141531026)

[1] [如何设计一个高性能百万的直播弹幕系统，听我娓娓道来 ...](https://blog.csdn.net/2401_89221445/article/details/144248964)

[2] [假如让你从 0 到 1 实现一个直播弹幕系统](https://cloud.tencent.com/developer/article/1645888)

[2] [实现高效直播弹幕功能：Spring Boot 的最佳技术选择](https://blog.csdn.net/guzhoumingyue/article/details/141531026)

[3] [直播系统聊天技术(九)：千万级实时直播弹幕的技术实践 - 即时 ...](https://segmentfault.com/a/1190000043949139)

[4] [bilibili 架构师 | 高并发实时弹幕系统的实战之路 - 腾讯云](https://cloud.tencent.com/developer/article/1679213)

[5] [打造实时弹幕王国：解密百万人级在线弹幕系统的奥秘 ...](https://cloud.tencent.com/developer/article/1679213)

[6] [基于 Netty 实现高性能弹幕系统\_牛客网](https://www.nowcoder.com/discuss/353148528853721088)

[7] [百万用户同时在线的高并发直播弹幕系统是如何实现 ...](https://zhuanlan.zhihu.com/p/36024676)

[8] [SpringBoot2 仿 B 站高性能前端+后端项目打造高性能的视频 ...](https://juejin.cn/post/7461286835308003380)

[9] [第三章 打造高性能的视频弹幕系统 - CSDN 博客](https://blog.csdn.net/sj15814963053/article/details/125664457)